{func
   dx_close_msg
   ;closes message if open
   {if {! {$this in_game}}
      {if $dx_msg_opened
         {set $dx_msg_opened FALSE}
         {$this hide_message}
      }
      {set $dx_no_message_sound FALSE} ;re-allows message sound to play after closing
   }
   
}
{func dx_open_msg
   ($message)
   ;opens player message panel on current player
   {if {&& $message {! {$this in_game}}}
      {if {! $dx_msg_opened}
         {set $dx_msg_opened TRUE}
         {$this show_message}
      }
      {set $dx_no_message_sound TRUE} ;prevents message sound from playing in menus
      {$this setup_message_text $message FALSE}
   }
}
{func
   dx_check_for_dupe ; function to allow 5L/Pro instruments together but still block same parts from being selected
   ($slot) ; current slot number of the user
   {do
      ($selected_part ; grabs the currently selected part of the user
         {switch $slot
            (0 $default_slot0)
            (1 $default_slot1)
            (2 $default_slot2)
            (3 $default_slot3)
         }
      )
      ($dupe_allowed TRUE) ; allows dupe TRUE by default, any check below will set it to FALSE
      {user_mgr foreach_user $user
         {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
            {if
               {==
                  {$user get_track_type}
                  {switch $selected_part
                     ((overshell_drums overshell_drums_pro) kTrackDrum)
                     (overshell_guitar kTrackGuitar)
                     (overshell_real_guitar kTrackRealGuitar)
                     (overshell_bass kTrackBass)
                     (overshell_real_bass kTrackRealBass)
                     (overshell_keys kTrackKeys)
                     (overshell_real_keys kTrackRealKeys)
                  }
               }
               {set $dupe_allowed FALSE} ; block dupe if another player already has this part
            }
         }
      }
      $dupe_allowed ; returns dupe TRUE/FALSE check back to slot_states
   }
}
{func
   dx_state_setup
   ($current_overshell_state $message)
   {unless $in_state ;the view code trick runs several times, so we need to make sure to only run the function once in the view
      {do
         ($menu_message 0)
         {set $in_state TRUE} ;gate it off REMEMBER, turn this to false when running this code in a reset handle
         {overshell_list_creation $current_overshell_state $options}
         {set $previous_state $current_state} ;don't rely on this this is only useful for a big switch state with many entry points, aka texture states
         {set $current_state $current_overshell_state}
         {foreach $entry $dx_state_tracker
            {if {== {elem $entry 0} $current_state}
               {$current_list set_selected {elem $entry 1}}
               {set $dx_tracked_changed FALSE}
               {if $message
                  {set $menu_message {sprint {elem $entry 1} "_desc"}}
               }
            }
         }
         {if $message
            {if {! $menu_message}
               {set $menu_message {sprint {elem $options 0} "_desc"}}
            }
            {dx_overshell_msg $menu_message}
         }
         {if_else {> {size $options} 6}
            {do
               {modifier_scroll.sbd set_showing TRUE}
               {modifier_scroll.sbd set scrollbar_list $current_list}
            }
            {do
               {modifier_scroll.sbd set_showing FALSE}
               {modifier_scroll.sbd set scrollbar_list modifiers.lst}
            }
         }
      }
   }
}

{func
   dx_state_pos_tracker
   ;{dx_log_writer insane {sprint "func: dx_state_pos_tracker"}}
   ;{dx_log_writer insane
   ;   {sprintf "Executed dx_state_pos_tracker - time: %.4fms"
   ;      {time
            {set $in_state FALSE}
            {if_else $dx_tracked_changed
               {set $current_state_pos $dx_tracked_changed} ;probe the item we will be switching too
               {set $current_state_pos {$current_list selected_sym}} ;probe the current list position
            }
            ;{unless $dx_tracked_changed
            ;   ;clean up the list for the state transition
            ;   {switch $num_of_slots
            ;      (1 {$current_list set_data (os_blnk)})
            ;      (2 {$current_list set_data (os_blnk os_blnk)})
            ;      (3 {$current_list set_data (os_blnk os_blnk os_blnk)})
            ;      (4 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk)})
            ;      (5 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk)})
            ;      (6 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk)})
            ;      (7 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk)})
            ;   }
            ;}
            ;this is stupid but it works
            {foreach $entry $dx_state_tracker
               {if {== {elem $entry 0} $current_state} ;first check if we have the state tracked already
                  {remove_elem $entry {elem $entry 1}} ;removed the previously tracked list position
                  {push_back $entry $current_state_pos} ;add in the new list position
               }
            }

            {foreach $entry $dx_state_tracker
               {if {!= {elem $entry 0} $current_state} ;check if the state isnt in the list
                  {set $pushtime_guitar TRUE} ;get ready to push it
               }
            }
            {foreach $entry $dx_state_tracker
               {if {== {elem $entry 0} $current_state} ;check the list again, and if it is in the list
                  {set $pushtime_guitar FALSE} ;dont push it
               }
            }
            {if $pushtime_guitar ;if we need to push
               {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
            }

            {foreach $entry $dx_state_tracker
               {if {!= {elem $entry 0} $current_state} ;check if the state isnt in the list
                  {set $pushtime_drum TRUE} ;get ready to push it
               }
            }
            {foreach $entry $dx_state_tracker
               {if {== {elem $entry 0} $current_state} ;check the list again, and if it is in the list
                  {set $pushtime_drum FALSE} ;dont push it
               }
            }
            {if $pushtime_drum ;if we need to push
               {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
            }
            
            {foreach $entry $dx_state_tracker
               {if {!= {elem $entry 0} $current_state} ;check if the state isnt in the list
                  {set $pushtime_bass TRUE} ;get ready to push it
               }
            }
            {foreach $entry $dx_state_tracker
               {if {== {elem $entry 0} $current_state} ;check the list again, and if it is in the list
                  {set $pushtime_bass FALSE} ;dont push it
               }
            }
            {if $pushtime_bass ;if we need to push
               {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
            }
            
            {foreach $entry $dx_state_tracker
               {if {!= {elem $entry 0} $current_state} ;check if the state isnt in the list
                  {set $pushtime_keys TRUE} ;get ready to push it
               }
            }
            {foreach $entry $dx_state_tracker
               {if {== {elem $entry 0} $current_state} ;check the list again, and if it is in the list
                  {set $pushtime_keys FALSE} ;dont push it
               }
            }
            {if $pushtime_keys ;if we need to push
               {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
            }
            {set $dx_state_tracker {array $dx_state_tracker}} ;re read the array so the vars enumerate and the array becomes static
            {$current_list set circular FALSE}
            {set $in_state FALSE}
                        ;{dx_log_writer insane {array $dx_state_tracker}}
   ;      }
   ;   }
   ;}
}
{func
   overshell_view_chooser
   ;{dx_log_writer insane {sprint "func: overshell_view_chooser"}}
   ;{dx_log_writer insane
   ;   {sprintf "Executed overshell_view_chooser - time: %.4fms"
   ;      {time
            ;{unless $in_state
            ;               ;}
            {set $actually_show_checks FALSE}
            {handle
               ($this
                  update_auto_vocals_enabled
                  {modifier_mgr is_modifier_active mod_auto_vocals})}
            {do
               ($no_fail_enabled
                  {modifier_mgr is_modifier_active mod_no_fail_band})
               {handle
                  ($this update_no_fail_enabled $no_fail_enabled)}}
            {set $dx_picked_view
               {switch $num_of_slots
                  (1 options_end_game)
                  (2 options_end_game)
                  (3 options_extras)
                  (4 gamercard_users)
                  (5 options)
                  (6 options_audio)
                  (7 game_options)
                  game_options
               }
            }
            $dx_picked_view
   ;      }
   ;   }
   ;}
}
{func same_list_reveal
   ($list $data $size)
   ;fake animation between dx states that use the same list
   {do
      ($list_temp {array 0})
      {foreach_int $i 0 $size
         {push_back $list_temp os_blnk}
      }
      {$list set_data $list_temp}
      {$list refresh}
      {$list set conceal_scale 150}
      {$list conceal}
      {script_task kTaskSeconds
         (delay 0.075)
         (script
            {$list reveal}
            {$list set conceal_scale 5}
            {$list set_data {array $data}}
            {$list refresh}
         )
      }
   }
}
{func dx_state
   ($state)
   {do
      ($this_list_content {array 0})
      ($dx_picked_view choose_char)
      ($prev_list $current_list)
      ($prev_group $dx_picked_view)
      ($num 0)
      ;get state or default to dx settings main
      {if_else $state
         {set $this_state $state}
         {set $this_state dxState_DeluxeSettings}
      }
      ;get list items from state array
      {foreach $entry {find $dx_settings_main $this_state view}
         ;view gets included so don't add it to the list
         {if {&& $entry {!= $entry view}}
            ;generate this list array
            {push_back $this_list_content $entry}
         }
      }
      ;cap max num shown in list to 7
      {set $num {size $this_list_content}}
      {if {> $num 8} {set $num 8}}
      ;pick the view for this
      {set $dx_picked_view
         {switch $num
            (1 auto_sign_in_rock_central)
            (2 options_end_game)
            (3 options_extras)
            (4 gamercard_users)
            (5 options)
            (6 options_av_settings)
            (7 game_options)
            (8 choose_char)
            choose_char
         }
      }
      ;pick the list for this
      {set $current_list
         {switch $num
            (1 auto_sign_in_rock_central.lst)
            (2 options_end_game.lst)
            (3 options_extras.lst)
            (4 users.lst)
            (5 options.lst)
            (6 options_av_settings.lst)
            (7 game_options.lst)
            (8 chars.lst)
            chars.lst
         }
      }
      {$current_list set display_num $num}
      {$current_list set min_display $num}
      {$current_list set max_display $num}
      {$current_list set scroll_past_max_display FALSE}
      {$current_list set scroll_time 0}
      {if_else {== $current_list users.lst}
         {gamercard_users.lbl set_showing FALSE}
         {gamercard_users.lbl set_showing TRUE}
      }
      {if_else {$this in_game}
         {$current_list set_type overshell_menu_ingame}
         {$current_list set_type overshell_menu}
      }
      ;circular breaks things
      ;{set $options_circular {>= {size $this_list_content} 12}}
      ;{$current_list set circular $options_circular}

      ;if we have setup a confirm dialog, we need to call it manually to see the nice description
      {if
         {&&
            {== {elem $this_list_content 0} overshell_continue}
            {== {elem $this_list_content 1} overshell_cancel}
         }
         {set $dx_picked_view confirm_action}
         {set $current_list confirm_action.lst}
      }
      ;(enter) in overshell state needs a slight delay to not be overwritten by vanilla state setup
      {script_task kTaskUISeconds
         (delay 0.1)
         (script
            ;call the handle to shift to correct view for state
            {do
               ($trigger {sprint "view_" $dx_picked_view ".trg"})
               ($initial_focus $current_list)
               ($in_track_mode {$this in_game})
               ;#ifdef HX_WII {view_default_wii.trg trigger} #endif
               
               ;{view_default.trg trigger}
               {view_default.trg set_view_pos $this $in_track_mode}
               {confirm_action.lst conceal}
               {$prev_list conceal}
               {confirm_action.grp set_showing FALSE}
               {{sprint $prev_group ".grp"} set_showing FALSE}
               {{sprint $dx_picked_view ".grp"} set_showing TRUE}
               {$current_list reveal}
               ;{$this conceal_all_lists {$trigger get hidden}}
               ;{$trigger trigger}
               {$trigger set_view_pos $this $in_track_mode}
               {$this set_focus $initial_focus}
               {if $in_track_mode
                  {track_mode.trg trigger}
               }
            }
            {if_else
               {&& ;HACK re-reveal the list if we are currently in it
                  {!= $last_state $this_state}
                  {== $num $previous_num_slot}
               }
               ;lmao
               {same_list_reveal $current_list $this_list_content $num}
               ;generate the list (normal reveal)
               {if_else {> {size $this_list_content} 0}
                  {$current_list set_data $this_list_content}
                  {$current_list set_data (no list data found)}
               }
            }
            {set $previous_num_slot $num}
            {set $last_state $this_state}
            {if {find_exists $dx_settings_main $this_state enter}
               {foreach $entry {find $dx_settings_main $this_state enter}
                  {if $entry
                     {eval $entry}
                  }
               }
            }
            ;close the message if going to a confirm screen, open otherwise
            {if_else {== $dx_picked_view confirm_action}
               {dx_close_msg}
               {dx_open_msg {sprint {$current_list selected_sym} "_desc"}}
            }
            {do
               ($show {> {size $this_list_content} 8})
               ;clean up and attach the scroll bar to this list (or not)
               {modifiers.grp set_showing $show}
               {modifiers.lst set_showing {! $show}}
               {modifiers.lbl set_showing {! $show}}
               {modifier_scroll.sbd set_showing $show}
               {if_else $show
                  {modifier_scroll.sbd set scrollbar_list $current_list}
                  {modifier_scroll.sbd set scrollbar_list modifiers.lst}
               }
            }
            {$current_list refresh}
         )
      }
   }
}
{func
   dx_auto_endurance_handler
   ; "{{$this get_user} set_track_type ...}" selects the part and will give the player a blank track if they don't have a part
   ; in Vocals case it'll default to Solo if no Harmony part exists
   {script_task kTaskSeconds
      (delay {if_else $dx_auto_endurance 0.2 0})
      (script
         {if {|| $dx_customizer $dx_auto_endurance}
            {switch
               {$this get_slot_num}
               (0 {{$this get_user} set_track_type kTrackGuitar})
               (1 
                  {do 
                     {$this select_drum_part TRUE}
                     {{$this get_user} set_track_type kTrackDrum}
                  }
               )
               (2 
                  {if_else {modifier_mgr is_modifier_active mod_auto_vocals}
                     {{$this get_user} set_track_type kTrackRealKeys}
                     {do
                        {$this select_vocal_part TRUE}
                        {{$this get_user} set_track_type kTrackVocals}  
                     }
                  }
               )
               (3 {{$this get_user} set_track_type kTrackBass})
               {fail {set $default_slot0 {$component selected_sym}}}
            }
            {$this show_state kState_ChooseDiff} ; force enter diff select even if song doesn't have a part
         }
      )
   }
}
{func
   store_choose_char_size_pos
   {unless $dx_stored_choose_char_defaults
      {set $dx_stored_choose_char_defaults TRUE}
      {set $dx_chose_char_default_pos_index_2 {choose_character.mesh get_local_pos_index 2}}
      {set $dx_chose_char_default_scale_index_0 {choose_character.mesh get_local_scale_index 0}}
      {set $dx_chose_char_default_scale_index_2 {choose_character.mesh get_local_scale_index 2}}
   }
}
{func
   restore_choose_char_size_pos
   {choose_character.mesh set_local_pos_index 2 $dx_chose_char_default_pos_index_2}
   {choose_character.mesh set_local_scale_index 0 $dx_chose_char_default_scale_index_0} ;X
   {choose_character.mesh set_local_scale_index 2 $dx_chose_char_default_scale_index_2} ;Y
   {choose_character.tex iterate_refs $ref {$ref set color {pack_color 1.0 1.0 1.0}}}
   {choose_character.tex iterate_refs $ref {$ref set intensify 0}}
   {choose_character.tex set_bitmap "dx/custom_textures/_additional_textures/choose_character.png"}
}
{func
   dx_quick_chat
   ($message)
   {set $user_name " "} {set $track_icon "G"} ; set default values if user_name or track icon cannot be obtained
   {set $user_name {$user get_user_name}}
   {if {== {ui current_screen} game_screen} {set $track_icon {$user get_track_icon}}}
   {if_else {== {ui current_screen} game_screen}
      {do ;if in-game, use Road Challange's tracker display to show a chat message
         {{coop_track_panel find tracker_broadcast_display} set_showing TRUE}
         {{{coop_track_panel find tracker_broadcast_display} find band_message.lbl} set_showing TRUE}
         {{coop_track_panel find tracker_broadcast_display} set_challenge_type kTrackerChallengeType_Streak}
         {{coop_track_panel find tracker_broadcast_display} set_display_type kBroadcastTrackerDisplay_BandMessage}
         {{coop_track_panel find tracker_broadcast_display} show_brief_band_message {symbol {sprintf "%s <alt>%s</alt>: %s" $user_name $track_icon $message}}}
         {unless {session_mgr is_local}
            {session send_msg_to_all
               {'`' 
                  (
                     {do
                        {{coop_track_panel find tracker_broadcast_display} set_showing TRUE}
                        {{{coop_track_panel find tracker_broadcast_display} find band_message.lbl} set_showing TRUE}
                        {{coop_track_panel find tracker_broadcast_display} set_challenge_type kTrackerChallengeType_Streak}
                        {{coop_track_panel find tracker_broadcast_display} set_display_type kBroadcastTrackerDisplay_BandMessage}
                        {{coop_track_panel find tracker_broadcast_display} show_brief_band_message {symbol {sprintf "%s <alt>%s</alt>: %s" {',' $user_name} {',' $track_icon} {',' $message}}}}
                     }
                  )
                  kNetReliable
               }
            }
         }
      }
      {do ;if not in-game, use passive_messages_panel instead to show a chat message
         {passive_messages_panel queue_message {symbol {sprintf "%s: %s" $user_name $message}}}
         {unless {session_mgr is_local}
            {session send_msg_to_all
               {'`' 
                  (
                     {passive_messages_panel queue_message {symbol {sprintf "%s: %s" {',' $user_name} {',' $message}}}}
                  )
                  kNetReliable
               }
            }
         }
      }
   }
}   
{func
   dx_cycle_aspect
   {set $dx_aspectratio {+ $dx_aspectratio 1}}
   {if
      {== $dx_aspectratio 4}
      {set $dx_aspectratio 0}}
   {cheat_display
      show
      {sprint
         "aspect ratio set to "
         {elem
            (square regular widescreen letterbox)
            $dx_aspectratio}}}
   {do
      {rnd set_aspect $dx_aspectratio}
   }
}
{func dx_modify_tracklength ($item_id $mod)

   {set $clamp_min 0.25}
   {set $clamp_max 4.0}
   {dx_log_writer insane {sprint "os modify track len " $item_id " " $mod " " $clamp_min " " $clamp_max}}
   {switch $item_id
      (0
         {dx_modify_tracklength 1 $mod}
         {set $tracklength_bass        $tracklength_guitar}
         {set $tracklength_drum        $tracklength_guitar}
         {set $tracklength_keys        $tracklength_guitar}
         {set $tracklength_real_keys   $tracklength_guitar}
         {set $tracklength_real_guitar $tracklength_guitar}
         {set $tracklength_real_bass   $tracklength_guitar}
      )
      (1
         {+= $tracklength_guitar $mod}
         {set $tracklength_guitar {clamp $tracklength_guitar $clamp_min $clamp_max}}
      )
      (2
         {+= $tracklength_bass $mod}
         {set $tracklength_bass {clamp $tracklength_bass $clamp_min $clamp_max}}
      )
      (3
         {+= $tracklength_drum $mod}
         {set $tracklength_drum {clamp $tracklength_drum $clamp_min $clamp_max}}
      )
      (4
         {+= $tracklength_keys $mod}
         {set $tracklength_keys {clamp $tracklength_keys $clamp_min $clamp_max}}
      )
      (5
         {+= $tracklength_real_guitar $mod}
         {set $tracklength_real_guitar {clamp $tracklength_real_guitar $clamp_min $clamp_max}}
      )
      (6
         {+= $tracklength_real_bass $mod}
         {set $tracklength_real_bass {clamp $tracklength_real_bass $clamp_min $clamp_max}}
      )
      (7
         {+= $tracklength_real_keys $mod}
         {set $tracklength_real_keys {clamp $tracklength_real_keys $clamp_min $clamp_max}}
      )
   }
   {set $dx_list_pos $item_id}
   {if {session is_in_game}
      {dx_track_update_lengths}
   }
}